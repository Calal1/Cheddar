/* Generated by Babel */
////// DEFINE PARSER ELEMENTS
"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EOF = 218;
var NONE = null;

// Character Classes

var UPPER = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
var LOWER = "abcdefghijklmnopqrstuvwxyz";
var WHITE = "\u0013\u0010\t\u0012 ";
var DIGIT = "0123456789";

// Tokenization Part Definitions

var TOKEN = UPPER + LOWER + "_";
var TOKEN_B = TOKEN + DIGIT;
var TOKEN_C = WHITE /* EOF */;

var VAR = TOKEN + "_";
var VAR_B = VAR + DIGIT;

var OP = "+-*/";

// Declerations

var ___FORMAL = new Map([["TOK_A", TOKEN], ["TOK_B", TOKEN]]);

/*
DEFINITION types

<TOK>  := <TOKEN> -><TOKEN_B><- <TOKEN_C>->
<TYPE> := <TOK>:<__::LEX>

<VARIABLE> := <VAR> -><VAR_B><-

<DEC> := <VARIABLE>
<DEC> := <TYPE>

<ITEM> := <DEC>
<ITEM> := <DEC>()
<ITEM> := <DEC>.<ITEM>

<EXPR> := ( <EXPR> )
<EXPR> := <ITEM> <OP> <ITEM>

<TOK> or <EXPR>
*/

//////////////////// START ////////////////////

/// START DATA
var CODE = "  //";

// TOKENIZER
var STDERR = "";
var STDLOG = ""; // Debug notes
(function () {

  var ITERATOR = 0;

  // Error handling
  function $ERROR(w, c, r) {
    STDERR += "Compile Error: " + w + " at " + c + ":" + r + "\n";
    ITERATOR = CODE.length;
  }

  function $TOKEN(n, c, r) {
    // Name, Column, Row
    $ERROR("Unexpected token \"" + n + "\"", c, r);
  }

  // Code Navigating Functions

  function __JUMP(palette) {
    // Jump through palette
    STDLOG += "JUMPED from " + ITERATOR;
    while (ITERATOR < CODE.length && palette.indexOf(CODE[ITERATOR]) > -1) ITERATOR++;
    STDLOG += " to " + ITERATOR + "\n";
  }

  function __SKIP(pa, pb, s) {
    // Returns between a two paritions
    if (CODE.slice(ITERATOR).indexOf(pa) === 0) {
      ITERATOR += pa.length; // JUMP
      do {
        if (ITERATOR < CODE.length) {
          ITERATOR++;
        } else {
          if (s !== EOF) {
            var _DIST = CODE.slice(0, ITERATOR);
            $TOKEN("EOF", ITERATOR - _DIST.lastIndexOf("\n"), _DIST.split("\n").length);
          } else {
            STDLOG += "SKIPED to EOF";
          }
          break;
        }
      } while (CODE.slice(ITERATOR).indexOf(pa) !== 0);
    } else {
      STDLOG += "Jumped __SKIP at " + ITERATOR + "\n";
    }
  }

  ////// TOKENIZATION DEFINITIONS /////

  var ___REGISTER = (function () {

    // Class Register
    // Creates Parse Register

    function ___REGISTER(FORM) {
      for (var _len = arguments.length, NEST = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        NEST[_key - 1] = arguments[_key];
      }

      _classCallCheck(this, ___REGISTER);

      this.FORM = FORM;
      this.REGISTER = new RegExp(FORM.replace(/<([A-Za-z_]+?)>/g, function (_, DATA) {
        return ___FORMAL.get(DATA).replace(/\\/g, "\\\\").replace(/]/g, "\\]");
      }).replace(/<<(\d+)>>/g, function (_, DATA) {
        return NEST[DATA];
      }));
    }

    // Handle resister checking

    _createClass(___REGISTER, [{
      key: "toString",
      value: function toString() {
        return this.FORM;
      }
    }]);

    return ___REGISTER;
  })();

  function __EXPRESSION() {

    __JUMP(WHITE);
    var __E_OP = "+-*/";
    //const __EOP
  }

  function __MATCH(REGISTER) {

    // for item in expand(register) {
    //   switch typeof item {
    //     case string:
    //       <= [item]
    //     case array:
    //       <= item[1]<item[0]>
    //   }
    // }

    if (REGISTER instanceof ___REGISTER) {
      // Register?

      // Get jump register
      var JUMP = REGISTER.REGISTER;

      // Set jump resgister
    } else {

        // Invalid parse register
        // Internal error

        $ERROR("Invalid Register", "INT", "INT::REGISTER");
      }
  }

  var Lexer = (function () {
    function Lexer(i, code) {
      _classCallCheck(this, Lexer);

      this.i = i;
      this.Code = code;

      this.Out = [];
    }

    // Retrieve current char at index
    // Lexer..get

    _createClass(Lexer, [{
      key: "keep",

      // Stores `..get`
      // Lexer..Out <- Lexer..get
      value: function keep() {
        this.Out.push(this.get);
      }

      // Closes lexer register
      //
    }, {
      key: "close",
      value: function close() {}
    }, {
      key: "get",
      get: function get() {
        return this.Code[this.i];
      }
    }]);

    return Lexer;
  })();

  for (; ITERATOR < CODE.length; ITERATOR++) {
    ///// LEVELED CORE /////
    var ____STREAM = { IN: 1, OUT: 2, ERR: 3 };

    ///// PREPROCCESSING /////

    // Align to Tokeen

    __JUMP(WHITE);

    // Comment Jumps

    __SKIP("/*", "*/", EOF);
    __SKIP("//", "\n", EOF);
    __SKIP("#", "\n", EOF);

    ////// DEFIINITION //////

    // Expression Definition

    var ___T_STR = new ___REGISTER();

    // Tokens
    var ___TOK = new ___REGISTER("[<TOKEN>][<TOK_B>]*");
    var ___TYPE = new ___REGISTER("<<0>>", ___TOK);

    // NOTE: syntax is still currently being descided
    // const ___TOK  = ___REGISTER([TOKEN, ["*", TOK_B]]);
    // const ___TYPE = ___REGISTER([___TOK, ":", ["//", "LEXOGRAPHIC DEFINITION"]]);

    __MATCH(___TOK);

    // OPEN
  }
})();

/////////// LEVELED DEFINITIONS ///////////

///
// == LEXICAL TYPES ==
// Expression
// Variable
// Closure
//
///
//__MACRO__("if", ___MACROSTATE([ ___EXPRESSION, ___CLOSURE ]), (E, C) => { })
//__MACRO__("def", ___MACROSTATE([ ___VARIABLE, ___TYPE ]), (V, T) => { })
//__MACRO__("while", ___MACROSTATE([ ___EXPRESSION, ___CLOSURE ]), (E, C) => { })